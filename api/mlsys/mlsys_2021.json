[
    {
        "title": "Boveda: Building an On-Chip Deep Learning Memory Hierarchy Brick by Brick",
        "abstract": "Data access between on- and off-chip memories account for a large fraction of overall energy consumption during inference with deep learning networks. On-chip memory compression can greatly reduce this energy cost as long as it balances the simplicity and low cost of the compression/decompression implementation and its effectiveness in data size reduction. We present Boveda, a simple and effective on-chip lossless memory compression technique for fixed-point precision networks. It reduces data widths by exploiting the value distribution deep learning applications naturally exhibit. Boveda can increase the effective on-chip capacity, reduce off-chip traffic, and/or achieve a desired performance/energy target while using smaller on-chip memories. Boveda can be placed after any memory block in the on-chip memory hierarchy and can work with \\textul{any} data-parallel processing units such as the vector-like or the tensorcore units of modern graphics processors, systolic arrays such as that used in the Tensor Processing Unit, and units that process sparse tensors such as those used in the SCNN accelerator. To demonstrate the potential of Boveda, we implement it over (i) SCNN, a state-of-the-art accelerator for sparse networks, (ii) a Tensorcore-like architecture, and (iii) TPU. Boveda reduces memory footprint by 34\\% for SCNN and sparse models on top of zero compression. For dense models, Boveda improves compression by 47\\%. We also present a prototype FPGA implementation.",
        "authors": [
            {
                "given_name": "Isak Edo",
                "family_name": "Vivancos",
                "institution": null
            },
            {
                "given_name": "Sayeh",
                "family_name": "Sharify",
                "institution": null
            },
            {
                "given_name": "Daniel",
                "family_name": "Ly-Ma",
                "institution": null
            },
            {
                "given_name": "Ameer",
                "family_name": "Abdelhadi",
                "institution": null
            },
            {
                "given_name": "Ciaran",
                "family_name": "Bannon",
                "institution": null
            },
            {
                "given_name": "Milos",
                "family_name": "Nikolic",
                "institution": null
            },
            {
                "given_name": "Mostafa",
                "family_name": "Mahmoud",
                "institution": null
            },
            {
                "given_name": "Alberto Delmas",
                "family_name": "Lascorz",
                "institution": null
            },
            {
                "given_name": "Gennady",
                "family_name": "Pekhimenko",
                "institution": null
            },
            {
                "given_name": "Andreas",
                "family_name": "Moshovos",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/013d407166ec4fa56eb1e1f8cbe183b9-Paper.pdf"
    },
    {
        "title": "To Bridge Neural Network Design and Real-World Performance: A Behaviour Study for Neural Networks",
        "abstract": "The boom of edge AI applications has spawned a great many neural network (NN) algorithms and inference platforms.  Unfortunately, the fast pace of development in their fields have magnified the gaps between them. A well-designed NN algorithm with reduced number of computation operations and memory accesses can easily result in increased inference latency in real-world deployment, due to a mismatch between the algorithm and the features of target platforms. Therefore, it is critical to understand the behaviour characteristics of NN design space on target platforms. However, none of existing NN benchmarking or characterization studies can serve this purpose. They only evaluate some sparse configurations in the design space for the purpose of platform optimization rather than the scaling in every design dimension for NN algorithm efficiency. This paper presents the first empirical study on the NN design space to learn NN behaviour characteristics on different inference platforms. The revealed characteristics can be used as guidelines to design efficient NN algorithms. We profile ten-thousand configurations from a cutting-edge NN design space on seven industrial edge AI platforms.  Seven key findings as well as their causes and implications for efficient NN design are highlighted.",
        "authors": [
            {
                "given_name": "Xiaohu",
                "family_name": "Tang",
                "institution": null
            },
            {
                "given_name": "Shihao",
                "family_name": "Han",
                "institution": null
            },
            {
                "given_name": "Li Lyna",
                "family_name": "Zhang",
                "institution": null
            },
            {
                "given_name": "Ting",
                "family_name": "Cao",
                "institution": null
            },
            {
                "given_name": "Yunxin",
                "family_name": "Liu",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/02522a2b2726fb0a03bb19f2d8d9524d-Paper.pdf"
    },
    {
        "title": "Cortex: A Compiler for Recursive Deep Learning Models",
        "abstract": "Optimizing deep learning models is generally performed in two steps: (i) high-level graph optimizations such as kernel fusion and (ii) low level kernel optimizations such as those found in vendor libraries. This approach often leaves significant performance on the table, especially for the case of recursive deep learning models. In this paper, we present Cortex, a compiler-based approach to generate highly-efficient code for recursive models for low latency inference. Our compiler approach and low reliance on vendor libraries enables us to perform end-to-end optimizations, leading to up to 14X lower inference latencies over past work, across different backends.",
        "authors": [
            {
                "given_name": "Pratik",
                "family_name": "Fegade",
                "institution": null
            },
            {
                "given_name": "Tianqi",
                "family_name": "Chen",
                "institution": null
            },
            {
                "given_name": "Phillip",
                "family_name": "Gibbons",
                "institution": null
            },
            {
                "given_name": "Todd",
                "family_name": "Mowry",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/182be0c5cdcd5072bb1864cdee4d3d6e-Paper.pdf"
    },
    {
        "title": "Adaptive Gradient Communication via Critical Learning Regime Identification",
        "abstract": "Distributed model training suffers from communication bottlenecks due to frequent model updates transmitted across compute nodes.  To alleviate these bottlenecks, practitioners use gradient compression techniques like sparsification, quantization, low rank updates etc. The techniques usually require choosing a static compression ratio, often requiring users to balance the trade-off between model accuracy and per-iteration speedup. In this work, we show that such performance degradation due to choosing a high compression ratio is not fundamental and that an adaptive compression strategy can reduce communication while maintaining final test accuracy.Inspired by recent findings on critical learning regimes, in which small gradient errors can have irrecoverable impact on model performance, we propose ACCORDION a simple yet effective adaptive compression algorithm. While ACCORDION maintains a high enough compression rate on average, it avoids detrimental impact by not compressing gradients too much whenever in critical learning regimes, detected by a simple gradient-norm based criterion. Our extensive experimental study over a number of machine learning tasks in distributed environments indicates that ACCORDION, maintains similar model accuracy to uncompressed training, yet achieves up to 5.5×better compression and up to 4.1×end-to-end speedup over static approaches. We show that ACCORDION also works for adjusting the batch size, another popular strategy for alleviating communication bottlenecks. Our code is available at https://github.com/uw-mad-dash/Accordion",
        "authors": [
            {
                "given_name": "Saurabh",
                "family_name": "Agarwal",
                "institution": null
            },
            {
                "given_name": "Hongyi",
                "family_name": "Wang",
                "institution": null
            },
            {
                "given_name": "Kangwook",
                "family_name": "Lee",
                "institution": null
            },
            {
                "given_name": "Shivaram",
                "family_name": "Venkataraman",
                "institution": null
            },
            {
                "given_name": "Dimitris",
                "family_name": "Papailiopoulos",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/1d7f7abc18fcb43975065399b0d1e48e-Paper.pdf"
    },
    {
        "title": "EXPLORING THE LIMITS OF CONCURRENCY IN ML TRAINING ON GOOGLE TPUS",
        "abstract": "Recent results in language understanding using neural networks have required training hardware of unprecedented scale, with thousands of chips cooperating on a single training run. This paper presents techniques to scale ML models on the Google TPU Multipod, a mesh with 4096 TPU-v3 chips. We discuss model parallelism to overcome scaling limitations from the fixed batch size in data parallelism, communication/collective optimizations, distributed evaluation of training metrics, and host input processing scaling optimizations. These techniques are demonstrated in both the TensorFlow and JAX programming frameworks. We also present performance results from the recent Google submission to the MLPerf-v0.7 benchmark contest, achieving record training times from 16 to 28 seconds in four MLPerf models on the Google TPU-v3 Multipod machine.",
        "authors": [
            {
                "given_name": "Sameer",
                "family_name": "Kumar",
                "institution": null
            },
            {
                "given_name": "Yu",
                "family_name": "Wang",
                "institution": null
            },
            {
                "given_name": "Cliff",
                "family_name": "Young",
                "institution": null
            },
            {
                "given_name": "James",
                "family_name": "Bradbury",
                "institution": null
            },
            {
                "given_name": "Naveen",
                "family_name": "Kumar",
                "institution": null
            },
            {
                "given_name": "Dehao",
                "family_name": "Chen",
                "institution": null
            },
            {
                "given_name": "Andy",
                "family_name": "Swing",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/28dd2c7955ce926456240b2ff0100bde-Paper.pdf"
    },
    {
        "title": "Lost in Pruning: The Effects of Pruning Neural Networks beyond Test Accuracy",
        "abstract": "Neural network pruning is a popular technique used to reduce the inference costs of modern, potentially overparameterized, networks. Starting from a pre-trained network, the  process is as follows: remove redundant parameters, retrain, and repeat while maintaining the same test accuracy. The result is a model that is a fraction of the size of the original with comparable predictive performance (test accuracy). Here, we reassess and evaluate whether the use of test accuracy alone in the terminating condition is sufficient to ensure that the resulting model performs well across a wide spectrum of \"harder\" metrics such as generalization to out-of-distribution data and resilience to noise. Across evaluations on varying architectures and data sets, we find that pruned networks effectively approximate the unpruned model, however, the prune ratio at which pruned networks achieve commensurate performance varies significantly across tasks. These results call into question the extent of \\emph{genuine} overparameterization in deep learning and raise concerns about the practicability of deploying pruned networks, specifically in the context of safety-critical systems, unless they are widely evaluated beyond test accuracy to reliably predict their performance. Our code is available at https://github.com/lucaslie/torchprune.",
        "authors": [
            {
                "given_name": "Lucas",
                "family_name": "Liebenwein",
                "institution": null
            },
            {
                "given_name": "Cenk",
                "family_name": "Baykal",
                "institution": null
            },
            {
                "given_name": "Brandon",
                "family_name": "Carter",
                "institution": null
            },
            {
                "given_name": "David",
                "family_name": "Gifford",
                "institution": null
            },
            {
                "given_name": "Daniela",
                "family_name": "Rus",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/2a79ea27c279e471f4d180b08d62b00a-Paper.pdf"
    },
    {
        "title": "Learning Fitness Functions for Machine Programming",
        "abstract": "The problem of automatic software generation has been referred to as machine programming.  In this work, we propose a framework based on genetic algorithms to help make progress in this domain. Although genetic algorithms (GAs) have been successfully used for many problems, one criticism is that hand-crafting GAs fitness function, the test that aims to effectively guide its evolution, can be notably challenging. Our framework presents a novel approach to learn the fitness function using neural networks to predict values of ideal fitness functions.We also augment the evolutionary process with a minimally intrusive search heuristic. This heuristic improves the framework’s ability to discover correct programs from ones that are approximately correct and does so with negligible computational overhead. We compare our approach with several state-of-the-art program synthesis methods and demonstrate that it finds more correct programs with fewer candidate program generations.",
        "authors": [
            {
                "given_name": "Shantanu",
                "family_name": "Mandal",
                "institution": null
            },
            {
                "given_name": "Todd",
                "family_name": "Anderson",
                "institution": null
            },
            {
                "given_name": "Javier",
                "family_name": "Turek",
                "institution": null
            },
            {
                "given_name": "Justin",
                "family_name": "Gottschlich",
                "institution": null
            },
            {
                "given_name": "Shengtian",
                "family_name": "Zhou",
                "institution": null
            },
            {
                "given_name": "Abdullah",
                "family_name": "Muzahid",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/32bb90e8976aab5298d5da10fe66f21d-Paper.pdf"
    },
    {
        "title": "Accelerating SLIDE Deep Learning on Modern CPUs: Vectorization, Quantizations, Memory Optimizations, and More",
        "abstract": "Deep learning implementations on CPUs (Central Processing Units) are gaining more traction. Enhanced AI capabilities on commodity x86 architectures are commercially appealing due to the reuse of existing hardware and virtualization ease. A notable work in this direction is the SLIDE system. SLIDE is a C++ implementation of a sparse hash table based back-propagation, which was shown to be significantly faster than GPUs in training hundreds of million parameter neural models. In this paper, we argue that SLIDE's current implementation is sub-optimal and does not exploit several opportunities available in modern CPUs. In particular, we show how SLIDE's computations allow for a unique possibility of vectorization via AVX (Advanced Vector Extensions)-512. Furthermore, we highlight opportunities for different kinds of memory optimization and quantizations. Combining all of them, we obtain up to 7x speedup in the computations on the same hardware. Our experiments are focused on large (hundreds of millions of parameters) recommendation and NLP models. Our work highlights several novel perspectives and opportunities for implementing randomized algorithms for deep learning on modern CPUs.",
        "authors": [
            {
                "given_name": "Shabnam",
                "family_name": "Daghaghi",
                "institution": null
            },
            {
                "given_name": "Nicholas",
                "family_name": "Meisburger",
                "institution": null
            },
            {
                "given_name": "Mengnan",
                "family_name": "Zhao",
                "institution": null
            },
            {
                "given_name": "Anshumali",
                "family_name": "Shrivastava",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/3636638817772e42b59d74cff571fbb3-Paper.pdf"
    },
    {
        "title": "IOS: Inter-Operator Scheduler for CNN Acceleration",
        "abstract": "To accelerate CNN inference, existing deep learning frameworks focus on optimizing intra-operator parallelization. However, a single operator can no longer fully utilize the available parallelism given the rapid advances in high-performance hardware, resulting in a large gap between the peak performance and the real performance. This performance gap is more severe under smaller batch sizes.  In this work, we extensively study the parallelism between operators and propose Inter-Operator Scheduler (IOS) to automatically schedule multiple operators' parallel execution through a novel dynamic programming algorithm. IOS consistently outperforms state-of-the-art libraries (e.g., TensorRT) by 1.1 to 1.5x on modern CNN benchmarks. The code to reproduce each experiment is available at: https://github.com/mit-han-lab/inter-operator-scheduler.",
        "authors": [
            {
                "given_name": "Yaoyao",
                "family_name": "Ding",
                "institution": null
            },
            {
                "given_name": "Ligeng",
                "family_name": "Zhu",
                "institution": null
            },
            {
                "given_name": "Zhihao",
                "family_name": "Jia",
                "institution": null
            },
            {
                "given_name": "Gennady",
                "family_name": "Pekhimenko",
                "institution": null
            },
            {
                "given_name": "Song",
                "family_name": "Han",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/38b3eff8baf56627478ec76a704e9b52-Paper.pdf"
    },
    {
        "title": "A Deep Learning Based Cost Model for Automatic Code Optimization",
        "abstract": "Enabling compilers to automatically optimize code has been a longstanding goal for the compiler community. Efficiently solving this problem requires using precise cost models. These models predict whether applying a sequence of code transformations reduces the execution time of the program. Building an analytical cost model to do so is hard in modern x86 architectures due to the complexity of the microarchitecture. In this paper, we present a novel deep learning based cost model for automatic code optimization. This model was integrated in a search method and implemented in the Tiramisu compiler to select the best code transformations. The input of the proposed model is a set of simple features representing the unoptimized code and a sequence of code transformations. The model predicts the speedup expected when the code transformations are applied. Unlike previous models, the proposed one works on full programs and does not rely on any heavy feature engineering. The proposed model has only 16% of mean absolute percentage error in predicting speedups on full programs. The proposed model enables Tiramisu to automatically find code transformations that match or are better than state-of-the-art compilers without requiring the same level of heavy feature engineering required by those compilers",
        "authors": [
            {
                "given_name": "Riyadh",
                "family_name": "Baghdadi",
                "institution": null
            },
            {
                "given_name": "Massinissa",
                "family_name": "Merouani",
                "institution": null
            },
            {
                "given_name": "Mohamed-Hicham",
                "family_name": "Leghettas",
                "institution": null
            },
            {
                "given_name": "Kamel",
                "family_name": "Abdous",
                "institution": null
            },
            {
                "given_name": "Taha",
                "family_name": "Arbaoui",
                "institution": null
            },
            {
                "given_name": "Karima",
                "family_name": "Benatchba",
                "institution": null
            },
            {
                "given_name": "Saman",
                "family_name": "Amarasinghe",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/3def184ad8f4755ff269862ea77393dd-Paper.pdf"
    },
    {
        "title": "Don't Forget to Sign the Gradients!",
        "abstract": "Engineering a top-notch deep learning model is an expensive procedure that involves collecting data, hiring human resources with expertise in machine learning, and providing high computational resources. For that reason, deep learning models are considered as valuable Intellectual Properties (IPs) of the model vendors. To ensure reliable commercialization of deep learning models, it is crucial to develop techniques to protect model vendors against IP infringements. One of such techniques that recently has shown great promise is digital watermarking. However, current watermarking approaches can embed very limited amount of information and are vulnerable against watermark removal attacks. In this paper, we present GradSigns, a novel watermarking framework for deep neural networks (DNNs). GradSigns embeds the owner's signature into the gradient of the cross-entropy cost function with respect to inputs to the model. Our approach has a negligible impact on the performance of the protected model and it allows model vendors to remotely verify the watermark through prediction APIs. We evaluate GradSigns on DNNs trained for different image classification tasks using CIFAR-10, SVHN, and YTF datasets. Experimental results show that GradSigns is robust against all known counter-watermark attacks and can embed a large amount of information into DNNs.",
        "authors": [
            {
                "given_name": "Omid",
                "family_name": "Aramoon",
                "institution": null
            },
            {
                "given_name": "Pin-Yu",
                "family_name": "Chen",
                "institution": null
            },
            {
                "given_name": "Gang",
                "family_name": "Qu",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/45fbc6d3e05ebd93369ce542e8f2322d-Paper.pdf"
    },
    {
        "title": "Nimble: Efficiently Compiling Dynamic Neural Networks for Model Inference",
        "abstract": "Modern deep neural networks increasingly make use of features such as control flow, dynamic data structures, and dynamic tensor shapes. Existing deep learning systems focus on optimizing and executing static neural networks which assume a pre-determined model architecture and input data shapes—assumptions that are violated by dynamic neural networks. Therefore, executing dynamic models with deep learning systems is currently both inflexible and sub-optimal, if not impossible. Optimizing dynamic neural networks is more challenging than static neural networks; optimizations must consider all possible execution paths and tensor shapes. This paper proposes Nimble, a high-performance and flexible system to optimize, compile, and execute dynamic neural networks on multiple platforms. Nimble handles model dynamism by introducing a dynamic type system, a set of dynamism-oriented optimizations, and a light-weight virtual machine runtime. Our evaluation demonstrates that Nimble outperforms existing solutions for dynamic neural networks by up to 20x on hardware platforms including Intel CPUs, ARM CPUs, and Nvidia GPUs.",
        "authors": [
            {
                "given_name": "Haichen",
                "family_name": "Shen",
                "institution": null
            },
            {
                "given_name": "Jared",
                "family_name": "Roesch",
                "institution": null
            },
            {
                "given_name": "Zhi",
                "family_name": "Chen",
                "institution": null
            },
            {
                "given_name": "Wei",
                "family_name": "Chen",
                "institution": null
            },
            {
                "given_name": "Yong",
                "family_name": "Wu",
                "institution": null
            },
            {
                "given_name": "Mu",
                "family_name": "Li",
                "institution": null
            },
            {
                "given_name": "Vin",
                "family_name": "Sharma",
                "institution": null
            },
            {
                "given_name": "Zachary",
                "family_name": "Tatlock",
                "institution": null
            },
            {
                "given_name": "Yida",
                "family_name": "Wang",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/4e732ced3463d06de0ca9a15b6153677-Paper.pdf"
    },
    {
        "title": "Rethinking Floating Point Overheads for Mixed Precision DNN Accelerators",
        "abstract": "Mixed precision DNN accelerators become more ubiquitous especially when both efficient training and inference are required. In this paper, we propose a mixed-precision convolution unit architecture which supports different integer and floating point~(FP) precisions. The proposed architecture is based on low-bit inner product units and realizes higher precision based on temporal decomposition.  We illustrate how to integrate FP computations on integer-based architecture and evaluate overheads incurred by FP arithmetic support. We argue that alignment and addition overhead for FP inner product can be significant since the maximum exponent difference could be up to 58 bits, which results into a large alignment logic. To address this issue, we illustrate empirically that at least 8 bits of alignment logic are required to maintain inference accuracy. We present novel optimizations based on the above observations to reduce the FP arithmetic hardware overheads. Our empirical results, based on simulation and hardware implementation, show significant reduction in FP16 overhead. Over typical mixed precision implementation, the proposed architecture achieves area improvements of up to 25\\% in TFLOPS/$mm^2$ and up to 46\\% in TOPS/$mm^2$ with power efficiency improvements of up to 40\\% in TFLOPS/W and up to 63\\% in TOPS/W.",
        "authors": [
            {
                "given_name": "Hamzah",
                "family_name": "Abdelaziz",
                "institution": null
            },
            {
                "given_name": "Ali",
                "family_name": "Shafiee",
                "institution": null
            },
            {
                "given_name": "Jong Hoon",
                "family_name": "Shin",
                "institution": null
            },
            {
                "given_name": "Ardavan",
                "family_name": "Pedram",
                "institution": null
            },
            {
                "given_name": "Joseph",
                "family_name": "Hassoun",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/5f93f983524def3dca464469d2cf9f3e-Paper.pdf"
    },
    {
        "title": "Swift for TensorFlow: A portable, flexible platform for deep learning",
        "abstract": "Swift for TensorFlow is a deep learning platform that scales from mobile devices to clusters of hardware accelerators in data centers. It combines a language-integrated automatic differentiation system and multiple Tensor implementations within a modern ahead-of-time compiled language oriented around mutable value semantics. The resulting platform has been validated through use in over 30 deep learning models and and has been employed across data center and mobile applications.",
        "authors": [
            {
                "given_name": "Brennan",
                "family_name": "Saeta",
                "institution": null
            },
            {
                "given_name": "Denys",
                "family_name": "Shabalin",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/5fd0b37cd7dbbb00f97ba6ce92bf5add-Paper.pdf"
    },
    {
        "title": "Equality Saturation for Tensor Graph Superoptimization",
        "abstract": "One of the major optimizations employed in deep learning frameworks is graph rewriting. Production frameworks rely on heuristics to decide if rewrite rules should be applied and in which order.  Prior research has shown that one can discover more optimal tensor computation graphs if we search for a better sequence of substitutions instead of relying on heuristics. However, we observe that existing approaches for tensor graph superoptimization both in production and research frameworks apply substitutions in a sequential manner. Such sequential search methods are sensitive to the order in which the substitutions are applied and often only explore a small fragment of the exponential space of equivalent graphs. This paper presents a novel technique for tensor graph superoptimization that employs equality saturation to apply all possible substitutions at once. We show that our approach can find optimized graphs with up to 16% speedup over state-of-the-art, while spending on average 48x less time optimizing.",
        "authors": [
            {
                "given_name": "Yichen",
                "family_name": "Yang",
                "institution": null
            },
            {
                "given_name": "Phitchaya",
                "family_name": "Phothilimthana",
                "institution": null
            },
            {
                "given_name": "Yisu",
                "family_name": "Wang",
                "institution": null
            },
            {
                "given_name": "Max",
                "family_name": "Willsey",
                "institution": null
            },
            {
                "given_name": "Sudip",
                "family_name": "Roy",
                "institution": null
            },
            {
                "given_name": "Jacques",
                "family_name": "Pienaar",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/65ded5353c5ee48d0b7d48c591b8f430-Paper.pdf"
    },
    {
        "title": "PipeMare: Asynchronous Pipeline Parallel DNN Training",
        "abstract": "Pipeline parallelism when training neural networks enables models to be partitioned spatially, which can lead to overall higher hardware utilization. Unfortunately, to preserve the statistical efficiency of sequential training, existing pipeline parallel training techniques sacrifice hardware efficiency by decreasing pipeline utilization or incurring extra memory costs. In this paper, we investigate to what extent these sacrifices will be necessary on the emerging class of new dataflow hardware accelerators. We devise PipeMare, a simple yet robust training method that tolerates asynchronous updates during pipeline parallel execution without sacrificing utilization or memory, which allows efficient use of fine-grained pipeline parallelism. Concretely, when tested on ResNet and Transformer networks, asynchrony enables PipeMare to use up to 2.7x less memory or get 14.3x higher pipeline utilization, with similar model quality, when compared to state-of-the-art synchronous pipeline parallel training techniques.",
        "authors": [
            {
                "given_name": "Bowen",
                "family_name": "Yang",
                "institution": null
            },
            {
                "given_name": "Jian",
                "family_name": "Zhang",
                "institution": null
            },
            {
                "given_name": "Jonathan",
                "family_name": "Li",
                "institution": null
            },
            {
                "given_name": "Christopher",
                "family_name": "Re",
                "institution": null
            },
            {
                "given_name": "Christopher",
                "family_name": "Aberger",
                "institution": null
            },
            {
                "given_name": "Christopher De",
                "family_name": "Sa",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/6c8349cc7260ae62e3b1396831a8398f-Paper.pdf"
    },
    {
        "title": "An Efficient Statistical-based Gradient Compression Technique for Distributed Training Systems",
        "abstract": "The recent many-fold increase in the size of deep neural networks makes efficient distributed training challenging. Many proposals exploit the compressibility of the gradients and propose lossy compression techniques to speed up the communication stage of distributed training. Nevertheless, compression comes at the cost of reduced model quality and extra computation overhead. In this work, we design an efficient compressor with minimal overhead. Noting the sparsity of the gradients, we propose to model the gradients as random variables distributed according to some sparsity-inducing distributions (SIDs). We empirically validate our assumption by studying the statistical characteristics of the evolution of gradient vectors over the training process. We then propose Sparsity-Inducing Distribution-based Compression (SIDCo), a threshold-based sparsification scheme that enjoys similar threshold estimation quality to deep gradient compression (DGC) while being faster by imposing lower compression overhead. Our extensive evaluation of popular machine learning benchmarks involving both recurrent neural network (RNN) and convolution neural network (CNN) models shows that SIDCo speeds up training by up to ~41.7X, 7.6X, and 1.9X compared to the no-compression baseline, Topk, and DGC compressors, respectively.",
        "authors": [
            {
                "given_name": "Ahmed M.",
                "family_name": "Abdelmoniem",
                "institution": null
            },
            {
                "given_name": "Ahmed",
                "family_name": "Elzanaty",
                "institution": null
            },
            {
                "given_name": "Mohamed-Slim",
                "family_name": "Alouini",
                "institution": null
            },
            {
                "given_name": "Marco",
                "family_name": "Canini",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/6ea9ab1baa0efb9e19094440c317e21b-Paper.pdf"
    },
    {
        "title": "Value Learning for Throughput Optimization of Deep Learning Workloads",
        "abstract": "As the usage of machine learning techniques is becoming ubiquitous, the efficient execution of deep learning models is crucial to many applications. Frameworks such as Halide or TVM separate the algorithmic representation of the neural network from the schedule that determines its implementation. Finding good schedules, however, remains extremely challenging. Autotuning methods, which search the space of valid schedules and execute each candidate on the hardware, identify some of the best performing schedules, but the search can take hours, hampering the productivity of deep learning practitioners. What is needed is a method that achieves a similar performance without extensive search, delivering the needed efficiency quickly. We model the scheduling process as a sequence of optimization choices, and present a new technique to accurately predict the expected performance of a partial schedule using a LSTM over carefully engineered features that describe each DNN operator and their current scheduling choices. Leveraging these predictions we are able to make these optimization decisions greedily, and without any executions on the target hardware, quickly identify an efficient schedule. Our evaluation shows that our performance predictions are one order of magnitude more accurate than the state of the art. This enables us to find schedules that improve the execution performance of deep neural networks by 1.5x or more over the best autoschedulers. Moreover, our technique is two to three orders of magnitude faster than these tools, and completes in seconds instead of hours.",
        "authors": [
            {
                "given_name": "Benoit",
                "family_name": "Steiner",
                "institution": null
            },
            {
                "given_name": "Chris",
                "family_name": "Cummins",
                "institution": null
            },
            {
                "given_name": "Horace",
                "family_name": "He",
                "institution": null
            },
            {
                "given_name": "Hugh",
                "family_name": "Leather",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/73278a4a86960eeb576a8fd4c9ec6997-Paper.pdf"
    },
    {
        "title": "Scaling Distributed Training with Adaptive Summation",
        "abstract": "Data parallelism is a common way to parallelize stochastic gradient descent (SGD). However, the loss of convergence at large minibatch sizes limits the scalability of data parallelism. This paper introduces a novel method to combine gradients called Adasum that significantly improves the convergence when using large minibatches. This paper provides the intuition and formal justification of Adasum along with a convergence proof. Additionally, the paper describes an efficient implementation of Adasum and its integration into the open-source toolkit Horovod for use in both TensorFlow and PyTorch. The paper empirically shows that Adasum improves convergence when using large minibatch sizes for multiple optimizers (Momentum-SGD, Adam, and LAMB). For BERT-Large training with a minibatch size of 64K, using both Adasum and LAMB training converges in 20% fewer epochs than with LAMB alone. This combination also allows BERT-Large training to scale to a 128K minibatch size. While one of the motivations for LAMB was the inability of the Adam optimizer to scale beyond a minibatch size of 16K, we show that Adasum helps Adam scale BERT-Large training to a 64K minibatch size. Our implementation of Adasum in Horovod has already been adopted in several production environments.",
        "authors": [
            {
                "given_name": "Saeed",
                "family_name": "Maleki",
                "institution": null
            },
            {
                "given_name": "Madan",
                "family_name": "Musuvathi",
                "institution": null
            },
            {
                "given_name": "Todd",
                "family_name": "Mytkowicz",
                "institution": null
            },
            {
                "given_name": "Olli",
                "family_name": "Saarikivi",
                "institution": null
            },
            {
                "given_name": "Tianju",
                "family_name": "Xu",
                "institution": null
            },
            {
                "given_name": "Vadim",
                "family_name": "Eksarevskiy",
                "institution": null
            },
            {
                "given_name": "Jaliya",
                "family_name": "Ekanayake",
                "institution": null
            },
            {
                "given_name": "Emad",
                "family_name": "Barsoum",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/757b505cfd34c64c85ca5b5690ee5293-Paper.pdf"
    },
    {
        "title": "Learning on Distributed Traces for Data Center Storage Systems",
        "abstract": "Storage services in data centers continuously make decisions, such as for cache admission, prefetching, and block allocation. These decisions are typically driven by heuristics based on statistical properties like temporal locality or common file sizes. The quality of decisions can be improved through application-level information such as the database operation a request belongs to. While such features can be exploited through application hints (e.g., explicit prefetches), this process requires manual work and is thus only viable for the most tuned workloads. In this work, we show how to leverage application-level information automatically, by building on distributed traces that are already available in warehouse-scale computers. As these traces are used for diagnostics and accounting, they contain information about requests, including those to storage services. However, this information is mostly unstructured (e.g., arbitrary text) and thus difficult to use. We demonstrate how to do so automatically using machine learning, by applying ideas from natural language processing. We show that different storage-related decisions can be learned from distributed traces, using models ranging from simple clustering techniques to neural networks. Instead of designing specific models for different storage-related tasks, we show that the same models can be used as building blocks for different tasks. Our models improve prediction accuracy by 11-33% over non-ML baselines, which translates to significantly improving the hit rate of a caching task, as well as improvements to an SSD/HDD tiering task, on production data center storage traces.",
        "authors": [
            {
                "given_name": "Giulio",
                "family_name": "Zhou",
                "institution": null
            },
            {
                "given_name": "Martin",
                "family_name": "Maas",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/82161242827b703e6acf9c726942a1e4-Paper.pdf"
    },
    {
        "title": "Pufferfish: Communication-efficient Models At No Extra Cost",
        "abstract": "To mitigate communication overheads in distributed model training, several studies propose the use of compressed stochastic gradients, usually achieved by sparsification or quantization. Such techniques achieve high compression ratios, but in many cases incur either significant computational overheads or some accuracy loss. In this work, we present Pufferfish, a communication and computation efficient distributed training framework that incorporates the gradient compression into the model training process via training low-rank, pre-factorized deep networks. Pufferfish not only reduces communication, but also completely bypasses any computation overheads related to compression, and achieves the same accuracy as state-of-the-art, off-the-shelf deep models. Pufferfish can be directly integrated into current deep learning frameworks with minimum implementation modification. Our extensive experiments over real distributed setups, across a variety of large-scale machine learning tasks, indicate that Pufferfish achieves up to 1.64x end-to-end speedup over the latest distributed training API in PyTorch without accuracy loss. Compared to the Lottery Ticket Hypothesis models, Pufferfish leads to equally accurate, small-parameter models while avoiding the burden of ``winning the lottery''. Pufferfish also leads to more accurate and smaller models than SOTA structured model pruning methods.",
        "authors": [
            {
                "given_name": "Hongyi",
                "family_name": "Wang",
                "institution": null
            },
            {
                "given_name": "Saurabh",
                "family_name": "Agarwal",
                "institution": null
            },
            {
                "given_name": "Dimitris",
                "family_name": "Papailiopoulos",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/84d9ee44e457ddef7f2c4f25dc8fa865-Paper.pdf"
    },
    {
        "title": "A Learned Performance Model for Tensor Processing Units",
        "abstract": "Accurate hardware performance models are critical to efficient code generation. They can be used by compilers to make heuristic decisions, by superoptimizers as a minimization objective, or by autotuners to find an optimal configuration for a specific program. However, they are difficult to develop because contemporary processors are complex, and the recent proliferation of deep learning accelerators has increased the development burden. We demonstrate a method of learning performance models from a corpus of tensor computation graph programs for Tensor Processing Unit (TPU) instances. We show that our learned model outperforms a heavily-optimized analytical performance model on two tasks—tile-size selection and operator fusion—and that it helps an autotuner discover faster programs in a setting where access to TPUs is limited or expensive.",
        "authors": [
            {
                "given_name": "Sam",
                "family_name": "Kaufman",
                "institution": null
            },
            {
                "given_name": "Phitchaya",
                "family_name": "Phothilimthana",
                "institution": null
            },
            {
                "given_name": "Yanqi",
                "family_name": "Zhou",
                "institution": null
            },
            {
                "given_name": "Charith",
                "family_name": "Mendis",
                "institution": null
            },
            {
                "given_name": "Sudip",
                "family_name": "Roy",
                "institution": null
            },
            {
                "given_name": "Amit",
                "family_name": "Sabne",
                "institution": null
            },
            {
                "given_name": "Mike",
                "family_name": "Burrows",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/85d8ce590ad8981ca2c8286f79f59954-Paper.pdf"
    },
    {
        "title": "Towards Scalable Distributed Training of Deep Learning on Public Cloud Clusters",
        "abstract": "Distributed training techniques have been widely deployed in large-scale deep models training on dense-GPU clusters. However, on public cloud clusters, due to the moderate inter-connection bandwidth between instances, traditional state-of-the-art distributed training systems cannot scale well in training large-scale models. In this paper, we propose a new computing and communication efficient top-k sparsification communication library for distributed training. To further improve the system scalability, we optimize I/O by proposing a simple yet efficient multi-level data caching mechanism and optimize the update operation by introducing a novel parallel tensor operator. Experimental results on a 16-node Tencent Cloud cluster (each node with 8 Nvidia Tesla V100 GPUs) show that our system achieves 25%-40% faster than existing state-of-the-art systems on CNNs and Transformer. We finally break the record on DAWNBench on training ResNet-50 to 93% top-5 accuracy on ImageNet.",
        "authors": [
            {
                "given_name": "Shaohuai",
                "family_name": "Shi",
                "institution": null
            },
            {
                "given_name": "Xianhao",
                "family_name": "Zhou",
                "institution": null
            },
            {
                "given_name": "Shutao",
                "family_name": "Song",
                "institution": null
            },
            {
                "given_name": "Xingyao",
                "family_name": "Wang",
                "institution": null
            },
            {
                "given_name": "Zilin",
                "family_name": "Zhu",
                "institution": null
            },
            {
                "given_name": "Xue",
                "family_name": "Huang",
                "institution": null
            },
            {
                "given_name": "Xinan",
                "family_name": "Jiang",
                "institution": null
            },
            {
                "given_name": "Feihu",
                "family_name": "Zhou",
                "institution": null
            },
            {
                "given_name": "Zhenyu",
                "family_name": "Guo",
                "institution": null
            },
            {
                "given_name": "Liqiang",
                "family_name": "Xie",
                "institution": null
            },
            {
                "given_name": "Rui",
                "family_name": "Lan",
                "institution": null
            },
            {
                "given_name": "Xianbin",
                "family_name": "Ouyang",
                "institution": null
            },
            {
                "given_name": "Yan",
                "family_name": "Zhang",
                "institution": null
            },
            {
                "given_name": "Jieqian",
                "family_name": "Wei",
                "institution": null
            },
            {
                "given_name": "Jing",
                "family_name": "Gong",
                "institution": null
            },
            {
                "given_name": "Weiliang",
                "family_name": "Lin",
                "institution": null
            },
            {
                "given_name": "Ping",
                "family_name": "Gao",
                "institution": null
            },
            {
                "given_name": "Peng",
                "family_name": "Meng",
                "institution": null
            },
            {
                "given_name": "Xiaomin",
                "family_name": "Xu",
                "institution": null
            },
            {
                "given_name": "Chenyang",
                "family_name": "Guo",
                "institution": null
            },
            {
                "given_name": "Bo",
                "family_name": "Yang",
                "institution": null
            },
            {
                "given_name": "Zhibo",
                "family_name": "Chen",
                "institution": null
            },
            {
                "given_name": "Yongjian",
                "family_name": "Wu",
                "institution": null
            },
            {
                "given_name": "Xiaowen",
                "family_name": "Chu",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/8613985ec49eb8f757ae6439e879bb2a-Paper.pdf"
    },
    {
        "title": "ModularNAS: Towards Modularized and Reusable Neural Architecture Search",
        "abstract": "Automated neural architecture search (NAS) methods have been demonstrated as a powerful tool to facilitate neural architecture design. However, the broad applicability of NAS has been restrained due to the difficulty of designing task-specific search spaces and the necessity and verbosity to implement every NAS component from scratch when switching to another search space. In this work, we propose ModularNAS, a framework that implements essential components of NAS in a modularized and unified manner. It enables automatic search space generation for customized use cases while reusing predefined search strategies, with little extra work needed for each case. We conduct extensive experiments to verify the improved model performance on various tasks by reusing supported NAS components over customized search spaces. We have also shown that targeting existing architectures, ModularNAS can find superior ones concerning accuracy and deployment efficiency, such as latency and FLOPS. The source code of our framework can be found at https://github.com/huawei-noah/vega/tree/master/vega/algorithms/nas/modnas.",
        "authors": [
            {
                "given_name": "Yunfeng",
                "family_name": "Lin",
                "institution": null
            },
            {
                "given_name": "Guilin",
                "family_name": "Li",
                "institution": null
            },
            {
                "given_name": "Xing",
                "family_name": "Zhang",
                "institution": null
            },
            {
                "given_name": "Weinan",
                "family_name": "Zhang",
                "institution": null
            },
            {
                "given_name": "Bo",
                "family_name": "Chen",
                "institution": null
            },
            {
                "given_name": "Ruiming",
                "family_name": "Tang",
                "institution": null
            },
            {
                "given_name": "Zhenguo",
                "family_name": "Li",
                "institution": null
            },
            {
                "given_name": "Jiashi",
                "family_name": "Feng",
                "institution": null
            },
            {
                "given_name": "Yong",
                "family_name": "Yu",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/8f14e45fceea167a5a36dedd4bea2543-Paper.pdf"
    },
    {
        "title": "FLAML: A Fast and Lightweight AutoML Library",
        "abstract": "We study the problem of using low computational cost to automate the choices of learners and hyperparameters for an ad-hoc training dataset and error metric, by conducting trials of different configurations on the given training data. We investigate the joint impact of multiple factors on both trial cost and model error, and propose several design guidelines.  Following them, we build a fast and lightweight library FLAML which optimizes for low computational resource in finding accurate models. FLAML integrates several simple but effective search strategies into an adaptive system. It significantly outperforms top-ranked AutoML libraries on a large open source AutoML benchmark under equal, or sometimes orders of magnitude smaller budget constraints.",
        "authors": [
            {
                "given_name": "Chi",
                "family_name": "Wang",
                "institution": null
            },
            {
                "given_name": "Qingyun",
                "family_name": "Wu",
                "institution": null
            },
            {
                "given_name": "Markus",
                "family_name": "Weimer",
                "institution": null
            },
            {
                "given_name": "Erkang",
                "family_name": "Zhu",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/92cc227532d17e56e07902b254dfad10-Paper.pdf"
    },
    {
        "title": "TT-Rec: Tensor Train Compression for Deep Learning Recommendation Models",
        "abstract": "The memory capacity of embedding tables in deep learning recommendation models (DLRMs) is increasing dramatically from tens of GBs to TBs across the industry. Given the fast growth in DLRMs, novel solutions are urgently needed in order to enable DLRM innovations. At the same time, this must be done in a fast and efficient way without having to exponentially increase infrastructure capacity demands. In this paper, we demonstrate the promising potential of Tensor Train decomposition for DLRMs (TT-Rec), an important yet under-investigated context. We design and implement optimized kernels (TT-EmbeddingBag) to evaluate the proposed TT-Rec design.  TT-EmbeddingBag is 3x faster than the SOTA TT implementation. The performance of TT-Rec is further optimized with the batched matrix multiplication and caching strategies for embedding vector lookup operations. In addition, we present mathematically and empirically the effect of weight initialization distribution on DLRM accuracy and propose to initialize the tensor cores of TT-Rec following the sampled Gaussian distribution. We evaluate TT-Rec across three important design space dimensions---memory capacity, accuracy, and timing performance---by training MLPerf-DLRM with Criteo's Kaggle and Terabyte data sets. TT-Rec compresses the model size by 4x to 221x for Kaggle, with 0.03% to 0.3% loss of accuracy correspondingly. For Terabyte, our approach achieves 112x model size reduction which comes with no accuracy loss nor training time overhead as compared to the uncompressed baseline.",
        "authors": [
            {
                "given_name": "Chunxing",
                "family_name": "Yin",
                "institution": null
            },
            {
                "given_name": "Bilge",
                "family_name": "Acun",
                "institution": null
            },
            {
                "given_name": "Carole-Jean",
                "family_name": "Wu",
                "institution": null
            },
            {
                "given_name": "Xing",
                "family_name": "Liu",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/979d472a84804b9f647bc185a877a8b5-Paper.pdf"
    },
    {
        "title": "SUOD: Accelerating Large-Scale Unsupervised Heterogeneous Outlier Detection",
        "abstract": "Outlier detection (OD) is a key machine learning (ML) task for identifying abnormal objects from general samples with numerous high-stake applications including fraud detection and intrusion detection. Due to the lack of ground truth labels, practitioners often have to build a large number of unsupervised, heterogeneous models (i.e., different algorithms with varying hyperparameters) for further combination and analysis, rather than relying on a single model. How to accelerate the training and scoring on new-coming samples by outlyingness (referred as prediction throughout the paper) with a large number of unsupervised, heterogeneous OD models? In this study, we propose a modular acceleration system, called SUOD, to address it. The proposed system focuses on three complementary acceleration aspects (data reduction for high-dimensional data, approximation for costly models, and taskload imbalance optimization for distributed environment), while maintaining performance accuracy. Extensive experiments on more than 20 benchmark datasets demonstrate SUOD's effectiveness in heterogeneous OD acceleration, along with a real-world deployment case on fraudulent claim analysis at IQVIA, a leading healthcare firm. We open-source SUOD for reproducibility and accessibility.",
        "authors": [
            {
                "given_name": "Yue",
                "family_name": "Zhao",
                "institution": null
            },
            {
                "given_name": "Xiyang",
                "family_name": "Hu",
                "institution": null
            },
            {
                "given_name": "Cheng",
                "family_name": "Cheng",
                "institution": null
            },
            {
                "given_name": "Cong",
                "family_name": "Wang",
                "institution": null
            },
            {
                "given_name": "Changlin",
                "family_name": "Wan",
                "institution": null
            },
            {
                "given_name": "Wen",
                "family_name": "Wang",
                "institution": null
            },
            {
                "given_name": "Jianing",
                "family_name": "Yang",
                "institution": null
            },
            {
                "given_name": "Haoping",
                "family_name": "Bai",
                "institution": null
            },
            {
                "given_name": "Zheng",
                "family_name": "Li",
                "institution": null
            },
            {
                "given_name": "Cao",
                "family_name": "Xiao",
                "institution": null
            },
            {
                "given_name": "Yunlong",
                "family_name": "Wang",
                "institution": null
            },
            {
                "given_name": "Zhi",
                "family_name": "Qiao",
                "institution": null
            },
            {
                "given_name": "Jimeng",
                "family_name": "Sun",
                "institution": null
            },
            {
                "given_name": "Leman",
                "family_name": "Akoglu",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/98dce83da57b0395e163467c9dae521b-Paper.pdf"
    },
    {
        "title": "Pipelined Backpropagation at Scale: Training Large Models without Batches",
        "abstract": "New hardware can substantially increase the speed and efficiency of deep neural network training. To guide the development of future hardware architectures, it is pertinent to explore the hardware and machine learning properties of alternative training algorithms. In this work we evaluate the use of small batch, fine-grained Pipelined Backpropagation, an asynchronous pipeline parallel training algorithm that has significant hardware advantages. We introduce two methods, Spike Compensation and Linear Weight Prediction, that effectively mitigate the downsides caused by the asynchronicity of Pipelined Backpropagation and outperform existing techniques in our setting. We show that appropriate normalization and small batch sizes can also aid training. With our methods, fine-grained Pipelined Backpropagation using a batch size of one can match the accuracy of SGD for multiple networks trained on CIFAR-10 and ImageNet. Simple scaling rules allow the use of existing hyperparameters for traditional training without additional tuning.",
        "authors": [
            {
                "given_name": "Atli",
                "family_name": "Kosson",
                "institution": null
            },
            {
                "given_name": "Vitaliy",
                "family_name": "Chiley",
                "institution": null
            },
            {
                "given_name": "Abhinav",
                "family_name": "Venigalla",
                "institution": null
            },
            {
                "given_name": "Joel",
                "family_name": "Hestness",
                "institution": null
            },
            {
                "given_name": "Urs",
                "family_name": "Koster",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/9b8619251a19057cff70779273e95aa6-Paper.pdf"
    },
    {
        "title": "Fluid: Resource-aware Hyperparameter Tuning Engine",
        "abstract": "Current hyperparameter tuning solutions lack complementary execution engines to efficiently leverage distributed computation, thus ignoring the possibility of intra- and inter-GPU sharing, which exhibits poor resource usage. In this paper, we present Fluid, a generalized hyperparameter tuning execution engine, that coordinates between hyperparameter tuning jobs and cluster resources. Fluid schedules evaluation trials in such jobs using a water-filling approach to make the best use of resources both at intra- and inter-GPU granularities to speed up the tuning process. By abstracting a hyperparameter tuning job as a sequence of TrialGroup, Fluid can boost the performance of diverse hyperparameter tuning solutions. Our experiments show that Fluid can speed up synchronous BOHB by 200%, and BOHB and ASHA by 30% while having similar final accuracy.",
        "authors": [
            {
                "given_name": "Peifeng",
                "family_name": "Yu",
                "institution": null
            },
            {
                "given_name": "Jiachen",
                "family_name": "Liu",
                "institution": null
            },
            {
                "given_name": "Mosharaf",
                "family_name": "Chowdhury",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/9f61408e3afb633e50cdf1b20de6f466-Paper.pdf"
    },
    {
        "title": "MicroNets: Neural Network Architectures for Deploying TinyML Applications on Commodity Microcontrollers",
        "abstract": "Executing machine learning workloads locally on resource constrained microcontrollers (MCUs) promises to drastically expand the application space of IoT. However, so-called TinyML presents severe technical challenges, as deep neural network inference demands a large compute and memory budget. To address this challenge, neural architecture search (NAS) promises to help design accurate ML models that meet the tight MCU memory, latency, and energy constraints.  A key component of NAS algorithms is their latency/energy model, i.e., the mapping from a given neural network architecture to its inference latency/energy on an MCU. In this paper, we observe an intriguing property of NAS search spaces for MCU model design: on average, model latency varies linearly with model operation (op) count under a uniform prior over models in the search space. Exploiting this insight, we employ differentiable NAS (DNAS) to search for models with low memory usage and low op count, where op count is treated as a viable proxy to latency. Experimental results validate our methodology, yielding our MicroNet models, which we deploy on MCUs using Tensorflow Lite Micro, a standard open-source neural network (NN) inference runtime widely used in the TinyML community. MicroNets demonstrate state-of-the-art results for all three TinyMLperf industry-standard benchmark tasks: visual wake words, audio keyword spotting, and anomaly detection. Models and training scripts can be found at https://github.com/ARM-software/ML-zoo.",
        "authors": [
            {
                "given_name": "Colby",
                "family_name": "Banbury",
                "institution": null
            },
            {
                "given_name": "Chuteng",
                "family_name": "Zhou",
                "institution": null
            },
            {
                "given_name": "Igor",
                "family_name": "Fedorov",
                "institution": null
            },
            {
                "given_name": "Ramon",
                "family_name": "Matas",
                "institution": null
            },
            {
                "given_name": "Urmish",
                "family_name": "Thakker",
                "institution": null
            },
            {
                "given_name": "Dibakar",
                "family_name": "Gope",
                "institution": null
            },
            {
                "given_name": "Vijay Janapa",
                "family_name": "Reddi",
                "institution": null
            },
            {
                "given_name": "Matthew",
                "family_name": "Mattina",
                "institution": null
            },
            {
                "given_name": "Paul",
                "family_name": "Whatmough",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/a3c65c2974270fd093ee8a9bf8ae7d0b-Paper.pdf"
    },
    {
        "title": "Doping: A technique for Extreme Compression of LSTM Models using Sparse Structured Additive Matrices",
        "abstract": "Structured matrices, such as those derived from Kronecker products (KP), are effective at compressing neural networks, but can lead to unacceptable accuracy loss when applied to large models. In this paper, we propose the notion of doping - addition of an extremely sparse matrix to a structured matrix. Doping facilitates additional degrees of freedom for a small number of parameters, allowing them to independently diverge from the fixed structure. To train LSTMs with doped structured matrices, we introduce the additional parameter matrix while slowly annealing its sparsity level. However, we find that performance degrades as we slowly sparsify the doping matrix, due to co-matrix adaptation (CMA) between the structured and the sparse matrices. We address this over dependence on the sparse matrix using a co-matrix dropout regularization (CMR) scheme. We provide empirical evidence to show that doping, CMA and CMR are concepts generally applicable to multiple structured matrices (Kronecker Product, LMF, Hybrid Matrix Decomposition). Additionally, results with doped kronecker product matrices demonstrate state-of-the-art accuracy at large compression factors (10 − 25x) across 4 natural language processing applications with minor loss in accuracy. Doped KP compression technique outperforms previous state-of-the art compression results by achieving 1.3−2.4x higher compression factor at a similar accuracy, while also beating strong alternatives like pruning and low-rank methods by a large margin (8% or more). Additionally, we show that doped KP can be deployed on commodity hardware using the current software stack and achieve 2.5 − 5.5x inference run-time speed-up over baseline.",
        "authors": [
            {
                "given_name": "Urmish",
                "family_name": "Thakker",
                "institution": null
            },
            {
                "given_name": "Paul",
                "family_name": "Whatmough",
                "institution": null
            },
            {
                "given_name": "Zhigang",
                "family_name": "Liu",
                "institution": null
            },
            {
                "given_name": "Matthew",
                "family_name": "Mattina",
                "institution": null
            },
            {
                "given_name": "Jesse",
                "family_name": "Beu",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/a3f390d88e4c41f2747bfa2f1b5f87db-Paper.pdf"
    },
    {
        "title": "A Distributed Graph-Theoretic Framework for Automatic Parallelization in Multi-core Systems",
        "abstract": "The rapid demand for memory and computational resources by the emerging complex applications requires multi-core parallel systems capable to scale the execution of these applications. In this paper, we propose a distributed graph-theoretic framework for automatic parallelization in multi-core systems, where the goal is to minimize the data communication while accounting for intrinsic functional interdependence and balancing the workloads among cores to improve the overall performance. Specifically, we design a general and flexible greedy-based vertex cut framework for partitioning LLVM IR graphs into clusters while taking into consideration the data communication and workload balance among clusters. Then, we map the clusters generated by the vertex cut algorithms onto a non-uniform memory access multi-core platform. Experimental results demonstrate that our proposed WB-Libra algorithm provides performance improvements of 1.56x and 1.86x over existing state-of-the-art approaches for 8 and 1024 clusters running on a multi-core platform, respectively.",
        "authors": [
            {
                "given_name": "Guixiang",
                "family_name": "Ma",
                "institution": null
            },
            {
                "given_name": "Yao",
                "family_name": "Xiao",
                "institution": null
            },
            {
                "given_name": "Theodore",
                "family_name": "Willke",
                "institution": null
            },
            {
                "given_name": "Nesreen",
                "family_name": "Ahmed",
                "institution": null
            },
            {
                "given_name": "Shahin",
                "family_name": "Nazarian",
                "institution": null
            },
            {
                "given_name": "Paul",
                "family_name": "Bogdan",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/a5e00132373a7031000fd987a3c9f87b-Paper.pdf"
    },
    {
        "title": "Bit Error Robustness for Energy-Efficient DNN Accelerators",
        "abstract": "Deep neural network (DNN) accelerators received considerable attention in past years due to saved energy compared to mainstream hardware. Low-voltage operation of DNN accelerators allows to further reduce energy consumption significantly, however, causes bit-level failures in the memory storing the quantized DNN weights. In this paper, we show that a combination of robust fixed-point quantization, weight clipping, and random bit error training (RandBET) improves robustness against random bit errors in (quantized) DNN weights significantly. This leads to high energy savings from both low-voltage operation as well as low-precision quantization. Our approach generalizes across operating voltages and accelerators, as demonstrated on bit errors from profiled SRAM arrays. We also discuss why weight clipping alone is already a quite effective way to achieve robustness against bit errors. Moreover, we specifically discuss the involved trade-offs regarding accuracy, robustness and precision: Without losing more than 1% in accuracy compared to a normally trained 8-bit DNN, we can reduce energy consumption on CIFAR-10 by 20%. Higher energy savings of, e.g., 30%, are possible at the cost of 2.5% accuracy, even for 4-bit DNNs.",
        "authors": [
            {
                "given_name": "David",
                "family_name": "Stutz",
                "institution": null
            },
            {
                "given_name": "Nandhini",
                "family_name": "Chandramoorthy",
                "institution": null
            },
            {
                "given_name": "Matthias",
                "family_name": "Hein",
                "institution": null
            },
            {
                "given_name": "Bernt",
                "family_name": "Schiele",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/a684eceee76fc522773286a895bc8436-Paper.pdf"
    },
    {
        "title": "Horizontally Fused Training Array: An Effective Hardware Utilization Squeezer for Training Novel Deep Learning Models",
        "abstract": "Driven by the tremendous effort in researching novel deep learning (DL) algorithms, the training cost of developing new models increases staggeringly in recent years. We analyze GPU cluster usage statistics from a top research institute for more insights into the hardware efficiency achieved by typical DL training jobs. Our study reveals that single-accelerator training jobs can dominate the cluster-wide resource consumption when launched repetitively (e.g., for hyper-parameter tuning) while severely under-utilizing the hardware. Fortunately, we observe that such workloads have the following unique characteristics: (i) the models among jobs often have the same types of operators with the same shapes, and (ii) the inter-model horizontal fusion of such operators is mathematically equivalent to other already well-optimized operators. Thus, to help DL researchers and practitioners effectively improve the hardware utilization of their novel DL training workloads, we propose Horizontally Fused Training Array (HFTA). HFTA is a new DL framework extension library that horizontally fuses the models from different repetitive jobs deeply down to operators and then trains them simultaneously on a shared accelerator. To show the generality of our solution, we apply HFTA to six DL models training on state-of-the-art accelerators (GPUs and TPUs). Our results indicate that HFTA is highly effective in improving hardware utilization and achieves up to 15.1x higher training throughput vs. the standard practice of running each job on a separate accelerator.",
        "authors": [
            {
                "given_name": "Shang",
                "family_name": "Wang",
                "institution": null
            },
            {
                "given_name": "Peiming",
                "family_name": "Yang",
                "institution": null
            },
            {
                "given_name": "Yuxuan",
                "family_name": "Zheng",
                "institution": null
            },
            {
                "given_name": "Xin",
                "family_name": "Li",
                "institution": null
            },
            {
                "given_name": "Gennady",
                "family_name": "Pekhimenko",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/a97da629b098b75c294dffdc3e463904-Paper.pdf"
    },
    {
        "title": "Characterizing and Taming Model Instability Across Edge Devices",
        "abstract": "The same machine learning model running on different edge devices may produce highly-divergent outputs on a nearly-identical input. Possible reasons for the divergence include differences in the device sensors, the device's signal processing hardware and software, and its operating system and processors. This paper presents the first methodical characterization of the variations in model prediction across real-world mobile devices. We demonstrate that accuracy is not a useful metric to characterize prediction divergence, and introduce a new metric, instability, which captures this variation. We characterize different sources for instability, and show that differences in compression formats and image signal processing account for significant instability in object classification models. Notably, in our experiments, 14-17% of images produced divergent classifications across one or more phone models. We evaluate three different techniques for reducing instability. In particular, we adapt prior work on making models robust to noise in order to fine-tune models to be robust to variations across edge devices. We demonstrate our fine-tuning techniques reduce instability by 75%.",
        "authors": [
            {
                "given_name": "Eyal",
                "family_name": "Cidon",
                "institution": null
            },
            {
                "given_name": "Evgenya",
                "family_name": "Pergament",
                "institution": null
            },
            {
                "given_name": "Zain",
                "family_name": "Asgar",
                "institution": null
            },
            {
                "given_name": "Asaf",
                "family_name": "Cidon",
                "institution": null
            },
            {
                "given_name": "Sachin",
                "family_name": "Katti",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/b53b3a3d6ab90ce0268229151c9bde11-Paper.pdf"
    },
    {
        "title": "Understanding and Improving Failure Tolerant Training for Deep Learning Recommendation with Partial Recovery",
        "abstract": "The paper proposes and optimizes a partial recovery training system, CPR, for recommendation models. CPR relaxes the consistency requirement by enabling non-failed nodes to proceed without loading checkpoints when a node fails during training, improving failure-related overheads. The paper is the first to the extent of our knowledge to perform a data-driven, in-depth analysis of applying partial recovery to recommendation models and identified a trade-off between accuracy and performance. Motivated by the analysis, we present CPR, a partial recovery training system that can reduce the training time and maintain the desired level of model accuracy by (1) estimating the benefit of partial recovery, (2) selecting an appropriate checkpoint saving interval, and (3) prioritizing to save updates of more frequently accessed parameters. Two variants of CPR, CPR-MFU and CPR-SSU, reduce the checkpoint-related overhead from 8.2--8.5% to 0.53--0.68% compared to full recovery, on a setup emulating the failure pattern and overhead of a production-scale cluster. While reducing overhead significantly, CPR achieves model quality on par with the more expensive full recovery scheme, training the state-of-the-art recommendation model using Criteo’s Terabyte CTR dataset. Our results also suggest that CPR can speed up training on a real production-scale cluster, without notably degrading the accuracy.",
        "authors": [
            {
                "given_name": "Kiwan",
                "family_name": "Maeng",
                "institution": null
            },
            {
                "given_name": "Shivam",
                "family_name": "Bharuka",
                "institution": null
            },
            {
                "given_name": "Isabel",
                "family_name": "Gao",
                "institution": null
            },
            {
                "given_name": "Mark",
                "family_name": "Jeffrey",
                "institution": null
            },
            {
                "given_name": "Vikram",
                "family_name": "Saraph",
                "institution": null
            },
            {
                "given_name": "Bor-Yiing",
                "family_name": "Su",
                "institution": null
            },
            {
                "given_name": "Caroline",
                "family_name": "Trippel",
                "institution": null
            },
            {
                "given_name": "Jiyan",
                "family_name": "Yang",
                "institution": null
            },
            {
                "given_name": "Mike",
                "family_name": "Rabbat",
                "institution": null
            },
            {
                "given_name": "Brandon",
                "family_name": "Lucia",
                "institution": null
            },
            {
                "given_name": "Carole-Jean",
                "family_name": "Wu",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/b73ce398c39f506af761d2277d853a92-Paper.pdf"
    },
    {
        "title": "FirePlace: Placing Firecraker Virtual Machines with Hindsight Imitation",
        "abstract": "Virtual machines (VM) form the foundation of modern cloud computing as they help logically abstract per-user compute from shared physical infrastructure. Users of these services require VMs of varying sizes and configurations, which the provider places on a set of physical machines (PMs). VMs on the same physical PM share memory and CPU resources so a bad packing directly impacts the quality of user experience. We consider the placement of Firecracker VMs (a form of Micro-VMs) -- lightweight VMs that are typically used for short lived tasks. Our objective is to place each VM as it arrives, so that the peak to average ratio of resource usage across PMs is minimized. Placement is challenging as we need to consider resource use in multiple dimensions, such as CPU and memory, and because resource use changes over time. Past approaches to similar problems have suggested that one could forecast VM resource use for placement. We see that in our production traffic, Micro-VM resource use is spiky and short lived, and that forecasting algorithms are not useful. We evaluate Reinforcement Learning (RL) approaches for this task, but find that off-the-shelf RL algorithms are not always performant. We present a forecasting free algorithm, called FirePlace, that learns the placement decision using a variant of hindsight optimization, which we call hindsight imitation. We evaluate our approach using a production traffic trace of Firecracker usage AWS Lambda. FirePlace improves upon baseline algorithms by 10% on a production data trace of 100K Firecracker VMs.",
        "authors": [
            {
                "given_name": "Bharathan",
                "family_name": "Balaji",
                "institution": null
            },
            {
                "given_name": "Christopher",
                "family_name": "Kakovitch",
                "institution": null
            },
            {
                "given_name": "Balakrishnan",
                "family_name": "Narayanaswamy",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/c0e190d8267e36708f955d7ab048990d-Paper.pdf"
    },
    {
        "title": "sensAI: ConvNets Decomposition via Class Parallelism for Fast Inference on Live Data",
        "abstract": "Convolutional Neural Networks (ConvNets) enable computers to excel on vision learning tasks such as image classification, object detection. Recently, real-time inference on live data is becoming more and more important. From a system perspective, it requires fast inference on each single, incoming data item (e.g.  1 image).  Two main-stream distributed model serving paradigms – data parallelism and model parallelism – are not necessarily desirable here, because we cannot further split a single input data piece via data parallelism, and model parallelism introduces huge communication overhead. To achieve live data inference with low latency, we propose sensAI, a novel and generic approach that decouples a CNN model into disconnected subnets, each is responsible for predicting certain class(es). We call this new model distribution paradigm as class parallelism. Experimental results show that, sensAI achieves up to 18x faster inference on single input data item with no or negligible accuracy loss on CIFAR-10, CIFAR-100 and ImageNet-1K datasets.",
        "authors": [
            {
                "given_name": "Guanhua",
                "family_name": "Wang",
                "institution": null
            },
            {
                "given_name": "Zhuang",
                "family_name": "Liu",
                "institution": null
            },
            {
                "given_name": "Brandon",
                "family_name": "Hsieh",
                "institution": null
            },
            {
                "given_name": "Siyuan",
                "family_name": "Zhuang",
                "institution": null
            },
            {
                "given_name": "Joseph",
                "family_name": "Gonzalez",
                "institution": null
            },
            {
                "given_name": "Trevor",
                "family_name": "Darrell",
                "institution": null
            },
            {
                "given_name": "Ion",
                "family_name": "Stoica",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/c4ca4238a0b923820dcc509a6f75849b-Paper.pdf"
    },
    {
        "title": "Larq Compute Engine: Design, Benchmark and Deploy State-of-the-Art Binarized Neural Networks",
        "abstract": "We introduce Larq Compute Engine (LCE), a state-of-the-art Binarized Neural Network (BNN) inference engine, and use this framework to investigate several important questions about the efficiency of BNNs and to design a new leading BNN architecture. LCE provides highly optimized implementations of binary operations and accelerates binary convolutions by 8.5 - 18.5x compared to their full-precision counterparts on Pixel 1 phones. LCE's integration with Larq and a sophisticated MLIR-based converter allow users to move smoothly from training to deployment. By extending TensorFlow and TensorFlow Lite, LCE supports models which combine binary and full-precision layers, and can be easily integrated into existing applications. Using LCE, we analyze the performance of existing BNN computer vision architectures and develop QuickNet, a simple, easy-to-reproduce BNN that outperforms existing binary networks in terms of latency and accuracy on ImageNet. Furthermore, we investigate the impact of full-precision shortcuts and the relationship between number of multiply-accumulate operations and model latency. We are convinced that empirical performance should drive BNN architecture design and hope this work will facilitate others to design, benchmark and deploy binary models.",
        "authors": [
            {
                "given_name": "Tom",
                "family_name": "Bannink",
                "institution": null
            },
            {
                "given_name": "Adam",
                "family_name": "Hillier",
                "institution": null
            },
            {
                "given_name": "Lukas",
                "family_name": "Geiger",
                "institution": null
            },
            {
                "given_name": "Tim De",
                "family_name": "Bruin",
                "institution": null
            },
            {
                "given_name": "Leon",
                "family_name": "Overweel",
                "institution": null
            },
            {
                "given_name": "Jelmer",
                "family_name": "Neeven",
                "institution": null
            },
            {
                "given_name": "Koen",
                "family_name": "Helwegen",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/c7e1249ffc03eb9ded908c236bd1996d-Paper.pdf"
    },
    {
        "title": "Wavelet: Efficient DNN Training with Tick-Tock Scheduling",
        "abstract": "DNNs have revolutionized across a wide range of applications, such as image classification, speech recognition and robotics control. As DNN models become more computationally expensive to train, parallel execution with multiple accelerators (e.g. GPUs) is adopted. System efficiency is a big issue when scaling out. However, as computation power increases, GPUs are under-utilized mainly due to limited local memory size. To address this memory bound, we present Wavelet, an efficient and generic approach that can fully utilize all the available on-device memory among GPUs involved in the distributed training job. Wavelet achieves near optimal on-device memory usage by adopting a simple scheduling scheme called Tick-Tock, which interleaves waves of peak memory usage among the accelerators. Evaluations on a variety of DNN models and tasks show that, Wavelet trains models up to 6.7x faster than commonly used parallelism techniques.",
        "authors": [
            {
                "given_name": "Guanhua",
                "family_name": "Wang",
                "institution": null
            },
            {
                "given_name": "Kehan",
                "family_name": "Wang",
                "institution": null
            },
            {
                "given_name": "Kenan",
                "family_name": "Jiang",
                "institution": null
            },
            {
                "given_name": "Xiangjun",
                "family_name": "Li",
                "institution": null
            },
            {
                "given_name": "Ion",
                "family_name": "Stoica",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/c81e728d9d4c2f636f067f89cc14862c-Paper.pdf"
    },
    {
        "title": "Data Movement Is All You Need: A Case Study on Optimizing Transformers",
        "abstract": "Transformers are one of the most important machine learning workloads today. Training one is a very compute-intensive task, often taking days or weeks, and significant attention has been given to optimizing transformers. Despite this, existing implementations do not efficiently utilize GPUs. We find that data movement is the key bottleneck when training. Due to Amdahl's Law and massive improvements in compute performance, training has now become memory-bound. Further, existing frameworks use suboptimal data layouts. Using these insights, we present a recipe for globally optimizing data movement in transformers. We reduce data movement by up to 22.91% and overall achieve a 1.30x performance improvement over state-of-the-art frameworks when training a BERT encoder layer and 1.19x for the entire BERT. Our approach is applicable more broadly to optimizing deep neural networks, and offers insight into how to tackle emerging performance bottlenecks.",
        "authors": [
            {
                "given_name": "Andrei",
                "family_name": "Ivanov",
                "institution": null
            },
            {
                "given_name": "Nikoli",
                "family_name": "Dryden",
                "institution": null
            },
            {
                "given_name": "Tal",
                "family_name": "Ben-Nun",
                "institution": null
            },
            {
                "given_name": "Shigang",
                "family_name": "Li",
                "institution": null
            },
            {
                "given_name": "Torsten",
                "family_name": "Hoefler",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/c9e1074f5b3f9fc8ea15d152add07294-Paper.pdf"
    },
    {
        "title": "Scaling Polyhedral Neural Network Verification on GPUs",
        "abstract": "Certifying the robustness of neural networks against adversarial attacks is critical to their reliable adoption in real-world systems including autonomous driving and medical diagnosis. Unfortunately, state-of-the-art verifiers either do not scale to larger networks or are too imprecise to prove robustness, which limits their practical adoption. In this work, we introduce GPUPoly, a scalable verifier that can prove the robustness of significantly larger deep neural networks than possible with prior work. The key insight behind GPUPoly is the design of custom, sound polyhedra algorithms for neural network verification on a GPU. Our algorithms leverage the available GPU parallelism and the inherent sparsity of the underlying verification task. GPUPoly scales to very large networks: for example, it can prove the robustness of a 1M neuron, 34-layer deep residual network in $\\approx$ 22 seconds. We believe GPUPoly is a promising step towards the practical verification of large real-world networks.",
        "authors": [
            {
                "given_name": "Christoph",
                "family_name": "Müller",
                "institution": null
            },
            {
                "given_name": "François",
                "family_name": "Serre",
                "institution": null
            },
            {
                "given_name": "Gagandeep",
                "family_name": "Singh",
                "institution": null
            },
            {
                "given_name": "Markus",
                "family_name": "Püschel",
                "institution": null
            },
            {
                "given_name": "Martin",
                "family_name": "Vechev",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/ca46c1b9512a7a8315fa3c5a946e8265-Paper.pdf"
    },
    {
        "title": "Accounting for Variance in Machine Learning Benchmarks",
        "abstract": "Strong empirical evidence that one machine-learning algorithm A outperforms another one B, ideally calls for multiple trials optimizing the learning pipeline over sources of variation such as data sampling, augmentation, parameter initialization, and hyperparameters choices. This is prohibitively expensive, and corners are cut to reach conclusions. We model the whole benchmarking process and all sources of variation, revealing that variance due to data sampling, parameter initialization and hyperparameter choice impact markedly machine learning benchmark. We analyze the predominant comparison methods used today in the light of this variance. We show a counter-intuitive result that a biased estimator with more source of variation will give better results, closer to the ideal estimator at a 51× reduction in compute cost. Using this we perform a detailed study on the error rate of detecting improvements, on five different deep-learning tasks/architectures. This study leads us to propose recommendations for future performance comparisons.",
        "authors": [
            {
                "given_name": "Xavier",
                "family_name": "Bouthillier",
                "institution": null
            },
            {
                "given_name": "Pierre",
                "family_name": "Delaunay",
                "institution": null
            },
            {
                "given_name": "Mirko",
                "family_name": "Bronzi",
                "institution": null
            },
            {
                "given_name": "Assya",
                "family_name": "Trofimov",
                "institution": null
            },
            {
                "given_name": "Brennan",
                "family_name": "Nichyporuk",
                "institution": null
            },
            {
                "given_name": "Justin",
                "family_name": "Szeto",
                "institution": null
            },
            {
                "given_name": "Nazanin Mohammadi",
                "family_name": "Sepahvand",
                "institution": null
            },
            {
                "given_name": "Edward",
                "family_name": "Raff",
                "institution": null
            },
            {
                "given_name": "Kanika",
                "family_name": "Madan",
                "institution": null
            },
            {
                "given_name": "Vikram",
                "family_name": "Voleti",
                "institution": null
            },
            {
                "given_name": "Samira Ebrahimi",
                "family_name": "Kahou",
                "institution": null
            },
            {
                "given_name": "Vincent",
                "family_name": "Michalski",
                "institution": null
            },
            {
                "given_name": "Tal",
                "family_name": "Arbel",
                "institution": null
            },
            {
                "given_name": "Chris",
                "family_name": "Pal",
                "institution": null
            },
            {
                "given_name": "Gael",
                "family_name": "Varoquaux",
                "institution": null
            },
            {
                "given_name": "Pascal",
                "family_name": "Vincent",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/cfecdb276f634854f3ef915e2e980c31-Paper.pdf"
    },
    {
        "title": "Amazon SageMaker Debugger: A System for Real-Time Insights into Machine Learning Model Training",
        "abstract": "Manual debugging is a common productivity drain in the machine learning (ML) lifecycle. Identifying underperforming training jobs requires constant developer attention and deep domain expertise. As state-of-the-art models grow in size and complexity, debugging becomes increasingly difficult. Just as unit tests boost traditional software development, an automated ML debugging library can save time and money. We present Amazon SageMaker Debugger, a machine learning feature that automatically identifies and stops underperforming training jobs. Debugger is a new feature of Amazon SageMaker that automatically captures relevant data during training and evaluation and presents it for online and offline inspection. Debugger helps users define a set of conditions, in the form of built-in or custom rules, that are applied to this data, thereby enabling users to catch training issues as well as monitor and debug ML model training in real-time. These rules save time and money by alerting the developer and terminating a problematic training job early.",
        "authors": [
            {
                "given_name": "Nathalie",
                "family_name": "Rauschmayr",
                "institution": null
            },
            {
                "given_name": "Vikas",
                "family_name": "Kumar",
                "institution": null
            },
            {
                "given_name": "Rahul",
                "family_name": "Huilgol",
                "institution": null
            },
            {
                "given_name": "Andrea",
                "family_name": "Olgiati",
                "institution": null
            },
            {
                "given_name": "Satadal",
                "family_name": "Bhattacharjee",
                "institution": null
            },
            {
                "given_name": "Nihal",
                "family_name": "Harish",
                "institution": null
            },
            {
                "given_name": "Vandana",
                "family_name": "Kannan",
                "institution": null
            },
            {
                "given_name": "Amol",
                "family_name": "Lele",
                "institution": null
            },
            {
                "given_name": "Anirudh",
                "family_name": "Acharya",
                "institution": null
            },
            {
                "given_name": "Jared",
                "family_name": "Nielsen",
                "institution": null
            },
            {
                "given_name": "Lakshmi",
                "family_name": "Ramakrishnan",
                "institution": null
            },
            {
                "given_name": "Ishan",
                "family_name": "Bhatt",
                "institution": null
            },
            {
                "given_name": "Kohen",
                "family_name": "Chia",
                "institution": null
            },
            {
                "given_name": "Neelesh",
                "family_name": "Dodda",
                "institution": null
            },
            {
                "given_name": "Zhihan",
                "family_name": "Li",
                "institution": null
            },
            {
                "given_name": "Jiacheng",
                "family_name": "Gu",
                "institution": null
            },
            {
                "given_name": "Miyoung",
                "family_name": "Choi",
                "institution": null
            },
            {
                "given_name": "Balajee",
                "family_name": "Nagarajan",
                "institution": null
            },
            {
                "given_name": "Jeffrey",
                "family_name": "Geevarghese",
                "institution": null
            },
            {
                "given_name": "Denis",
                "family_name": "Davydenko",
                "institution": null
            },
            {
                "given_name": "Sifei",
                "family_name": "Li",
                "institution": null
            },
            {
                "given_name": "Lu",
                "family_name": "Huang",
                "institution": null
            },
            {
                "given_name": "Edward",
                "family_name": "Kim",
                "institution": null
            },
            {
                "given_name": "Tyler",
                "family_name": "Hill",
                "institution": null
            },
            {
                "given_name": "Krishnaram",
                "family_name": "Kenthapadi",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/d1f491a404d6854880943e5c3cd9ca25-Paper.pdf"
    },
    {
        "title": "RL-Scope: Cross-stack Profiling for Deep Reinforcement Learning Workloads",
        "abstract": "Deep reinforcement learning (RL) has made groundbreaking advancements in robotics, data center management and other applications.  Unfortunately, system-level bottlenecks in RL workloads are poorly understood; we observe fundamental structural differences in RL workloads that make them inherently less GPU-bound than supervised learning (SL).  To explain where training time is spent in RL workloads, we propose RL-Scope, a cross-stack profiler that scopes low-level CPU/GPU resource usage to high-level algorithmic operations, and provides accurate insights by correcting for profiling overhead.  Using RL-Scope, we survey RL workloads across its major dimensions including ML backend, RL algorithm, and simulator.  For ML backends, we explain a 2.3× difference in runtime between equivalent PyTorch and TensorFlow algorithm implementations, and identify a bottleneck rooted in overly abstracted algorithm implementations.  For RL algorithms and simulators, we show that on-policy algorithms are at least 3.5× more simulation-bound than off-policy algorithms.  Finally, we profile a scale-up workload and demonstrate that GPU utilization metrics reported by commonly used tools dramatically inflate GPU usage, whereas RL-Scope reports true GPU-bound time.  RL-Scope is an open-source tool available at https://github.com/UofT-EcoSystem/rlscope.",
        "authors": [
            {
                "given_name": "James",
                "family_name": "Gleeson",
                "institution": null
            },
            {
                "given_name": "Moshe",
                "family_name": "Gabel",
                "institution": null
            },
            {
                "given_name": "Gennady",
                "family_name": "Pekhimenko",
                "institution": null
            },
            {
                "given_name": "Eyal De",
                "family_name": "Lara",
                "institution": null
            },
            {
                "given_name": "Srivatsan",
                "family_name": "Krishnan",
                "institution": null
            },
            {
                "given_name": "Vijay Janapa",
                "family_name": "Reddi",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/d1fe173d08e959397adf34b1d77e88d7-Paper.pdf"
    },
    {
        "title": "TensorFlow Lite Micro: Embedded Machine Learning for TinyML Systems",
        "abstract": "We introduce TensorFlow (TF) Micro, an open-source machine learning inference framework for running deep-learning models on embedded systems. TF Micro tackles the efficiency requirements imposed by embedded system resource constraints and the fragmentation challenges that make cross-platform interoperability nearly impossible. The framework adopts a unique interpreter-based approach that provides flexibility while overcoming the challenges. This paper explains the design decisions behind TF Micro and describes its implementation. We present an evaluation to demonstrate its low resource requirement and minimal run-time performance overhead.",
        "authors": [
            {
                "given_name": "Robert",
                "family_name": "David",
                "institution": null
            },
            {
                "given_name": "Jared",
                "family_name": "Duke",
                "institution": null
            },
            {
                "given_name": "Advait",
                "family_name": "Jain",
                "institution": null
            },
            {
                "given_name": "Vijay Janapa",
                "family_name": "Reddi",
                "institution": null
            },
            {
                "given_name": "Nat",
                "family_name": "Jeffries",
                "institution": null
            },
            {
                "given_name": "Jian",
                "family_name": "Li",
                "institution": null
            },
            {
                "given_name": "Nick",
                "family_name": "Kreeger",
                "institution": null
            },
            {
                "given_name": "Ian",
                "family_name": "Nappier",
                "institution": null
            },
            {
                "given_name": "Meghna",
                "family_name": "Natraj",
                "institution": null
            },
            {
                "given_name": "Tiezhen",
                "family_name": "Wang",
                "institution": null
            },
            {
                "given_name": "Pete",
                "family_name": "Warden",
                "institution": null
            },
            {
                "given_name": "Rocky",
                "family_name": "Rhodes",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/d2ddea18f00665ce8623e36bd4e3c7c5-Paper.pdf"
    },
    {
        "title": "ByzShield: An Efficient and Robust System for Distributed Training",
        "abstract": "Training of large scale models on distributed clusters is a critical component of the machine learning pipeline. However, this training can easily be made to fail if some workers behave in an adversarial (Byzantine) fashion whereby they return arbitrary results to the parameter server (PS). A plethora of existing papers consider a variety of attack models and propose robust aggregation and/or computational redundancy to alleviate the effects of these attacks. In this work we consider an omniscient attack model where the adversary has full knowledge about the gradient computation assignments of the workers and can choose to attack (up to) any q out of K worker nodes to induce maximal damage. Our redundancy-based method ByzShield leverages the properties of bipartite expander graphs for the assignment of tasks to workers; this helps to effectively mitigate the effect of the Byzantine behavior. Specifically, we demonstrate an upper bound on the worst case fraction of corrupted gradients based on the eigenvalues of our constructions which are based on mutually orthogonal Latin squares and Ramanujan graphs. Our numerical experiments indicate over a 36% reduction on average in the fraction of corrupted gradients compared to the state of the art. Likewise, our experiments on training followed by image classification on the CIFAR-10 dataset show that ByzShield has on average a 20% advantage in accuracy under the most sophisticated attacks. ByzShield also tolerates a much larger fraction of adversarial nodes compared to prior work.",
        "authors": [
            {
                "given_name": "Konstantinos",
                "family_name": "Konstantinidis",
                "institution": null
            },
            {
                "given_name": "Aditya",
                "family_name": "Ramamoorthy",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/d9d4f495e875a2e075a1a4a6e1b9770f-Paper.pdf"
    },
    {
        "title": "In-network Aggregation for Shared Machine Learning Clusters",
        "abstract": "We present PANAMA, a network architecture for machine learning (ML) workloads on shared clusters where a variety of training jobs co-exist.PANAMA consists of two key components: (i) an efficient in-network hardware accelerator designed to accelerate large data-parallel training transfers; and (ii) a lightweight congestion control protocol to enable fair sharing of network resources across different flows. Our congestion control protocol exploits the unique communication pattern in training to ensure large in-network aggregation transfers do not negatively impact short latency-sensitive flows. To evaluate the feasibility of PANAMA, we build an FPGA-based prototype with 10 Gbps transceivers and show that our hardware datapath achieves line-rate aggregation. Our large-scale simulations demonstrate that PANAMA improves the mean and 99%-tile completion time of latency-sensitive short flows by a factor of 2–4.5 while reducing the average training time of large jobs by a factor of 1.25.",
        "authors": [
            {
                "given_name": "Nadeen",
                "family_name": "Gebara",
                "institution": null
            },
            {
                "given_name": "Manya",
                "family_name": "Ghobadi",
                "institution": null
            },
            {
                "given_name": "Costa",
                "family_name": "Paolo",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/eae27d77ca20db309e056e3d2dcd7d69-Paper.pdf"
    },
    {
        "title": "MicroRec: Efficient Recommendation Inference by Hardware and Data Structure Solutions",
        "abstract": "Deep neural networks are widely used in personalized recommendation systems. Unlike regular DNN inference workloads, recommendation inference is memory-bound due to the many random memory accesses needed to lookup the embedding tables. The inference is also heavily constrained in terms of latency because producing a recommendation for a user must be done in about tens of milliseconds. In this paper, we propose MicroRec, a high-performance inference engine for recommendation systems. MicroRec accelerates recommendation inference by (1) redesigning the data structures involved in the embeddings to reduce the number of lookups needed and (2) taking advantage of the availability of High-Bandwidth Memory (HBM) in FPGA accelerators to tackle the latency by enabling parallel lookups. We have implemented the resulting design on an FPGA board including the embedding lookup step as well as the complete inference process. Compared to the optimized CPU baseline (16 vCPU, AVX2-enabled), MicroRec achieves 13.8~14.7x  speedup on embedding lookup alone and 2.5~5.4x speedup for the entire recommendation inference in terms of throughput. As for latency, CPU-based engines needs milliseconds for inferring a recommendation while MicroRec only takes microseconds, a significant advantage in real-time recommendation systems.",
        "authors": [
            {
                "given_name": "Wenqi",
                "family_name": "Jiang",
                "institution": null
            },
            {
                "given_name": "Zhenhao",
                "family_name": "He",
                "institution": null
            },
            {
                "given_name": "Shuai",
                "family_name": "Zhang",
                "institution": null
            },
            {
                "given_name": "Thomas B.",
                "family_name": "Preußer",
                "institution": null
            },
            {
                "given_name": "Kai",
                "family_name": "Zeng",
                "institution": null
            },
            {
                "given_name": "Liang",
                "family_name": "Feng",
                "institution": null
            },
            {
                "given_name": "Jiansong",
                "family_name": "Zhang",
                "institution": null
            },
            {
                "given_name": "Tongxuan",
                "family_name": "Liu",
                "institution": null
            },
            {
                "given_name": "Yong",
                "family_name": "Li",
                "institution": null
            },
            {
                "given_name": "Jingren",
                "family_name": "Zhou",
                "institution": null
            },
            {
                "given_name": "Ce",
                "family_name": "Zhang",
                "institution": null
            },
            {
                "given_name": "Gustavo",
                "family_name": "Alonso",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/ec8956637a99787bd197eacd77acce5e-Paper.pdf"
    },
    {
        "title": "Accelerate Inference of CNNs for Video Analysis While Preserving Exactness Exploiting Activation Sparsity",
        "abstract": "This paper proposes a range-bound-aware convolution layer that accelerates the inference of rectified linear unit (ReLU)-based convolutional neural networks (CNNs) for analyzing video streams. Since video analysis systems require to process each video frame in real-time, the computational cost of inference of CNNs must be reduced. Several techniques heuristically skip the computation for the current frame and reuse the results of the previous frame when the current and previous frames are sufficiently similar. However, for critical applications such as surveillance systems, their accuracy can be unsatisfactory because they sacrifice accuracy for efficiency. In contrast, our method reduces the computational cost of convolution layers accompanied by ReLU while producing exactly the same inference results as an original model. We utilize both temporal similarity of video frames and activation sparsity in ReLU-based CNNs to guarantee to skip truly redundant computations. We experimentally confirm that our method can accelerate widely used pre-trained CNNs with both CPU and GPU implementations.",
        "authors": [
            {
                "given_name": "Toshiaki",
                "family_name": "Wakatsuki",
                "institution": null
            },
            {
                "given_name": "Sekitoshi",
                "family_name": "Kanai",
                "institution": null
            },
            {
                "given_name": "Yasuhiro",
                "family_name": "Fujiwara",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/f033ab37c30201f73f142449d037028d-Paper.pdf"
    },
    {
        "title": "VS-Quant: Per-vector Scaled Quantization for Accurate Low-Precision Neural Network Inference",
        "abstract": "Quantization enables efficient acceleration of deep neural networks by reducing model memory footprint and exploiting low-cost integer math hardware units. Quantization maps floating-point weights and activations in a trained model to low-bitwidth integer values using scale factors. Excessive quantization, reducing precision too aggressively, results in  accuracy degradation.  When scale factors are shared at a coarse granularity across many dimensions of each tensor, effective precision of individual elements within the tensor are limited. To reduce quantization-related accuracy loss, we propose using a separate scale factor for each small vector of (~16-64) elements within a single dimension of a tensor. To achieve an efficient hardware implementation, the per-vector scale factors can be implemented with low-bitwidth integers when calibrated using a two-level quantization scheme. We find that per-vector scaling consistently achieves better inference accuracy at low precision compared to conventional scaling techniques for popular neural networks without requiring retraining. We also modify a deep learning accelerator hardware design to study the area and energy overheads of per-vector scaling support. Our evaluation demonstrates that per-vector scaled quantization with 4-bit weights and activations achieves 69% energy saving and 36% area saving over an 8-bit baseline while maintaining over 75% accuracy for ResNet50 on ImageNet. 4-bit weights and 8-bit activations achieve near-full-precision accuracy for both BERT-base and BERT-large on SQuAD while reducing area by 28% compared to an 8-bit baseline.",
        "authors": [
            {
                "given_name": "Steve",
                "family_name": "Dai",
                "institution": null
            },
            {
                "given_name": "Rangha",
                "family_name": "Venkatesan",
                "institution": null
            },
            {
                "given_name": "Mark",
                "family_name": "Ren",
                "institution": null
            },
            {
                "given_name": "Brian",
                "family_name": "Zimmer",
                "institution": null
            },
            {
                "given_name": "William",
                "family_name": "Dally",
                "institution": null
            },
            {
                "given_name": "Brucek",
                "family_name": "Khailany",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/f0935e4cd5920aa6c7c996a5ee53a70f-Paper.pdf"
    },
    {
        "title": "CODE: Compiler-based Neuron-aware Ensemble training",
        "abstract": "Deep Neural Networks (DNNs) are redefining the state-of-the-art performance in a variety of tasks like speech recognition and image classification. These impressive results are often enabled by ensembling many DNNs together. Surprisingly, ensembling is often done by training several DNN instances from scratch and combining them.  This paper shows that there is significant redundancy in today's way of ensembling. The novelty we propose is CODE, a compiler approach designed to automatically generate DNN ensembles while avoiding unnecessary retraining among its DNNs.  For this purpose, CODE introduces neuron-level analyses and transformations aimed at identifying and removing redundant computation from the networks that compose the ensemble. Removing redundancy enables CODE to train large DNN ensembles in a fraction of the time and memory footprint needed by current techniques. These savings can be leveraged by CODE to increase the output quality of its ensembles.",
        "authors": [
            {
                "given_name": "Ettore M. G.",
                "family_name": "Trainiti",
                "institution": null
            },
            {
                "given_name": "Thanapon",
                "family_name": "Noraset",
                "institution": null
            },
            {
                "given_name": "David",
                "family_name": "Demeter",
                "institution": null
            },
            {
                "given_name": "Doug",
                "family_name": "Downey",
                "institution": null
            },
            {
                "given_name": "Simone",
                "family_name": "Campanoni",
                "institution": null
            }
        ],
        "url": "https://proceedings.mlsys.org/paper/2021/file/fa7cdfad1a5aaf8370ebeda47a1ff1c3-Paper.pdf"
    }
]